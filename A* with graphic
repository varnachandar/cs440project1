from contextlib import nullcontext
import tkinter as tk
import random # to generate a random no. for the index to block
import os
import math
import sys
#from os.path import exists

f = open("grid.txt", "r")

window = tk.Tk()

canvas = tk.Canvas(window, bg='white', height=1000, width=1000) #using the 1000 1000 gives a height of 50 and width of 100 tbh idk why
canvas.pack(fill=tk.BOTH, expand=True)

coordinates = set()
place = 0

for line in f:
    if place == 1:
        endx, endy = line.split()
        endx = int(endx) *10
        endy = int(endy) * 10
        place = place+1
    elif place == 0:
        startx,starty = line.split()
        startx = int(startx) *10
        starty = int(starty) *10
        place = place+1
    else:
        x,y,b = line.split() 
        b = int(b)
        x = int(x)
        y = int(y)
        if (b == 1):
            coordinates.add((x*10,y*10))

        
for i in range (0,1000,10): # the for loop lets us make the squares with size 10 across the entire canvas
  for j in range(0,500,10): # also in a sense we have coordinates now but in increments of 10 instead of 1, can't do one by one bcs then you just end up with a big black block since it is rly just the outlines smushed together
        if (i,j) in coordinates: # this is the part that we will have to randomize
            #create rectangle has parameters x1,y1,x2,y2 where x1 y1 is the start coordinate and x2,y2 is the end coordinate
            #outline is the outline color and fill is the fill color
           canvas.create_rectangle(i, j, i+10, j+10, outline = 'black', fill='gray')
        else:
           canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'white')

canvas.create_oval(startx-4, starty-4, startx+4, starty+4, outline = 'black', fill='red') 
canvas.create_oval(endx-4, endy-4, endx+4, endy+4, outline = 'black', fill='red')

f.close()



#### A* STARTS FROM HERE

f = open("grid.txt", "r")

# some sort of list with 0's and 1's for blocked and blocked in order of the coordinates use an array

# corr coordinate is (x-1)*50 + 2 + y only +1 not +2 bcs the file starts at place 1 or no adding? just -1

# manually find neightbors: 
    # above: x,y+1
    # below : x,y-1
    # left: x-1,y
    # right: x+1, y
    # diagonal up right: x+1, y+1
    # diagonal up left: x-1, y+1
    # diagonal down right: x+1, y-1
    # diagonal down left: x-1, y-1
        # with diagonal how would we check for blocked... since only the top left is marked as blocked... this can happen if we go diagonally up right 
            # do a case so that if the one directly above is blocked then we can't go top right

        

blocked = []
gval = []
parent = []




#next(f) # skips the first two lines of the file with the start and end index since those are formated diff
#next(f)

place = 0 # to keep track of just the first two lines
for line in f:
    if place == 1:
        endx, endy = line.split()
        endx = int(endx)
        endy = int(endy)
        place = place+1
    elif place == 0:
        startx,starty = line.split()
        startx = int(startx)
        starty = int(starty)
        place = place+1
    else:
        x,y,b = line.split() # don't rly need x and y we can find them on our own
        b = int(b)
        blocked.append(b) 
        gval.append(float('inf')) # all the g vals are initialy 0
        parent.append([0,0]) # all of the parents are just (0,0) initially


#print(startx)
#print(starty)
#print(endx)
#print(endy)
#print(blocked) #this was just to test that it was working to an extent

fringe = [] # can insert before other elements according to the distance 

closed = set() # no duplicates allowed and can find if smtg is in it or not and order of adding doesn't matter


#endx = 36
#endy = 0

def heuristic(x,y):
   #return 0
   a = math.sqrt(2)
   e = min(abs(x-endx), abs(y-endy))
   i = max(abs(x-endx), abs(y-endy))
   o = min(abs(x-endx), abs(y-endy))
   u = (a*e) + i - o
   
   return u
   #return ((math.sqrt(2)* min(abs(x-36)-abs(y-0)))+max(abs(x-36)-abs(y-0))-min(abs(x-36)-abs(y-0)))
   #return (math.sqrt(2)* min(abs(x-endx)-abs(y-endy)))+  max(abs(x-endx)-abs(y-endy))-min(abs(x-endx)-abs(y-endy))


def findIndex (x,y): # gives the index for the arrays for gval and parent
    return ((x-1)*50) + y -1

def cfunc(a, b, c, d): # finds the distance btwn two points
    xd = c-a
    xd = math.pow(xd,2)
    yd = d-b
    yd = math.pow(yd,2)
    d = math.sqrt(xd+yd)
    return d

def elementOf(arrayx, x, y): # using an array with the elements in the format [x,y], val; want to know if a certain coordinate is already in the array
    if (len(arrayx) == 0):
        return 0

    for i in (0,len(arrayx)-1):
        xval = arrayx[i][0][0] 
        yval = arrayx[i][0][1]
        if x == xval and y == yval:
            return 1 # 1 if the coordinate is in the array already
    return 0

def remove(arrayx,x,y): # want to remove a certain coordinate from the array again in the format [x,y],val
    if (len(arrayx) == 0):
        return

    for i in (0,len(arrayx)-1):
        xval = arrayx[i][0][0]
        yval = arrayx[i][0][1]
        if x == xval and y == yval:
            arrayx.pop(i)
            return

def insert(arrayx, x, y, val): # insert to an array of format [x,y]
    if(len(arrayx) == 0): # if the array has ntg in it, just append
        arrayx.append([[x,y],val])
        return 

    for i in (0,len(arrayx)-1): # if the array has values, to make it a priority queue, insert it a certain way
        value = arrayx[i][1]
        if (val<=value):
            arrayx.insert(i,[[x,y],val]) # insert in a way that the first element will be smallest and we go in increasing order and the last is the largest val
            return
    arrayx.append([[x,y],val]) # add to the end if it has the greatest val


def UpdateVertex(a,b, c, d): 
    index_s = findIndex(a,b)
    index_sprime = findIndex(c,d)
    cval = cfunc(a,b,c,d)

    if gval[index_s] + cval < gval[index_sprime]:
        gval[index_sprime] = gval[index_s] +cval
        parent[index_sprime] = [a,b]
        if elementOf(fringe,c,d):
            remove(fringe,c,d)
        
        val = gval[index_sprime] #+ heuristic(c,d)
        insert(fringe, c, d, val)
    else: # this changed nothing
        if not elementOf(fringe,c,d):
            val = gval[index_sprime] #+ heuristic(c,d)
            insert(fringe,c,d,val)
        



#instead of this use startx and starty


successor = [] 

def findSuccessor (arrayx,x,y): # finding the 8 neighbors
    if (x+1 < 101):
        if(not ((y == 1 and blocked[findIndex(x,y)] == 1) or (y == 50 and blocked[findIndex(x,y+1)] == 1))): # if we are at the top or bottom and its blocked
            if(not(blocked[findIndex(x,y)] == 1 and blocked[findIndex(x,y+1)] == 1)): # if going right and it is blocked and the one above is blocked
                if not (x+1, y) in closed:
                    arrayx.append([x+1,y])
        if(y+1 < 51) and blocked[findIndex(x,y+1)] != 1: # we aren't going diagonal up right through a blocked one
            if not (x+1, y+1) in closed:
                arrayx.append([x+1,y+1])
        if(y-1 > 0) and blocked[findIndex(x,y)] != 1: #don't go diagonally down right through blocked one
            if not (x+1, y-1) in closed:
                arrayx.append([x+1,y-1])
    if (x-1 > 0):
        if(not ((y == 1 and blocked[findIndex(x-1,y)] == 1) or (y == 50 and blocked[findIndex(x-1,y+1)] == 1))): # if we are at the top or bottom and its blocked
            if(not(blocked[findIndex(x-1,y)] == 1 and blocked[findIndex(x-1,y+1)] == 1)): # if going left and the left one and the one above the left one is blocked
                if not (x-1, y) in closed:
                    arrayx.append([x-1,y])
        if(y+1 < 51) and blocked[findIndex(x-1,y-1)] != 1: # we aren't going diagonal up left through a blocked one
            if not (x-1, y+1) in closed:
                arrayx.append([x-1,y+1])
        if(y-1 > 0) and blocked[findIndex(x-1,y)] != 1: # not going diagonally down left
            if not (x-1, y-1) in closed:
                arrayx.append([x-1,y-1])
    if(y+1 < 51):
        if not ((x == 1 and blocked[findIndex(x,y+1)] == 1)  or (x == 100 and blocked[findIndex(x-1,y+1)] == 1)): # on the edge and blocked
            if(not(blocked[findIndex(x,y+1)] == 1 and blocked[findIndex(x-1,y+1)] == 1)): # if going up, the one above and the one to the left of the above isn't blocked
                if not (x, y+1) in closed:
                    arrayx.append([x,y+1])
    if(y-1 > 0):
        if not ((x == 1 and blocked[findIndex(x,y)] == 1)  or (x == 100 and blocked[findIndex(x-1,y)] == 1)): # on the edge and blocked
             if(not(blocked[findIndex(x,y-1)] == 1 and blocked[findIndex(x-1,y-1)] == 1)): # if going down, the one below and the one to the left of the below isn't blocked
                if not (x, y-1) in closed:
                    arrayx.append([x,y-1])


def traceBack (x,y):
    index = findIndex(x,y)
    [px,py] = parent[index]
    xi = x
    yi = y
    while not(xi == startx and yi == starty):
        i = px*10
        j = py*10
        # need 8 cases type of thing for each dir plus more for blocked

        if(xi-px == 1): # from px we went to the right
            if yi-py == 1:
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue') # from px we went down diagonal path
            elif yi-py == -1:
                canvas.create_rectangle(i, j+10, i+10, j, outline = 'black',fill = 'blue') # from px we went up diagonal path
            else:
                #went to the right above a blocked one
                if(gval[findIndex(px,py)] == 1 or py == 50): # the one above a blocked one CANNOT be blocked if we went to the right over it
                    canvas.create_rectangle(i, j-10, i+10, j, outline = 'black',fill = 'blue')
                else: # went to the right above an unblocked one
                    canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif(xi-px == -1): # from px we went to the left
            if yi-py == 1:
                canvas.create_rectangle(i-10, j, i, j+10, outline = 'black',fill = 'blue') # from px we went down diagonal path
            elif yi-py == -1:
                canvas.create_rectangle(i-10, j+10, i, j, outline = 'black',fill = 'blue') # from px we went up diagonal path
            else:
                #went to the left above a blocked one
                if(gval[findIndex(px-1,py)] == 1 or py == 50): # the one above a blocked one CANNOT be blocked if we went to the left over it
                    canvas.create_rectangle(i-10, j-10, i, j, outline = 'black',fill = 'blue')
                else: # went to the left above an unblocked one
                    canvas.create_rectangle(i-10, j, i, j+10, outline = 'black',fill = 'blue')
        else: # didn't move left or right
            if(yi-py == 1): # went down
                if(gval[findIndex(px,py)] == 1 or px == 100): # the one to the right is blocked or at the edge
                    canvas.create_rectangle(i-10, j, i, j+10, outline = 'black',fill = 'blue')
                else:
                    canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            elif(yi-py == -1): # went up
                if(gval[findIndex(px,py-1)] == 1 or px == 100): # the one to the right is blocked or at edge
                    canvas.create_rectangle(i-10, j-10, i, j, outline = 'black',fill = 'blue')
                else:
                    canvas.create_rectangle(i, j-10, i+10, j, outline = 'black',fill = 'blue')

        #canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        indexP = findIndex(px,py)
        xi = px
        yi = py
        [px,py] = parent[indexP]
        

# but what if it goes across a blocked square... not actually going inside but across the top or the left?
# go to the one above? but we don't know if it is going across and how?
# also what if the first move is going left or up, so then we don't exactly fill in the square for startx,starty

def tracetest():
    index = findIndex(endx,endy)
    [px,py] = parent[index]

    while not (px == startx and py == starty):
        print(parent[index])
        index = findIndex(px,py)
        [px,py] = parent[index]




def main():
    indexS = findIndex(startx,starty)
    gval[indexS] = 0
    parent[indexS] = [startx,starty]
    val = gval[indexS] #+heuristic(startx,starty)
    insert(fringe, startx,starty,val)

    while len(fringe) != 0:
        #print(fringe)
        [[x,y],v] = fringe.pop()
        #print(x)
        #print(y)
        #print(v)
        if x == endx and y == endy:
            #print(gval)
            print("path found")
            #print(parent) # at the end EVERY SINGLE vertex HAS a parent
            traceBack(x,y)
            #tracetest()
            #print("TRACETEST RAN")
            return
            #window.mainloop()
            #sys.exit()


        closed.add((x,y))

        #successor = []
        findSuccessor(successor,x,y)
        #print(successor)
        

        while len(successor) != 0:
            [sx,sy] = successor.pop()
            if not (sx, sy) in closed:
                if not elementOf(fringe,sx,sy):
                    si = findIndex(sx,sy)
                    gval[si] = float('inf')
                    parent[si] = None
                UpdateVertex(x,y,sx,sy)
        #print(successor) # should be empty
        #print(fringe)

    print("no path found")
    return 
    


    


if __name__ == "__main__":
    main()




window.mainloop()
