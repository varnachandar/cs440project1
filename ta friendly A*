import tkinter as tk
import math

# global variables
blocked = [] # 0 if unblocked, 1 if blocked
gval = [] # holds the g(n)
parent = [] # holds the parents of a vertex
#successor = [] # used for the neighbors of a vertex
#path = [] # used at the end to assemble the path
fringe = [] # open list
closed = [] # closed list


# create the Tkinter window
window = tk.Tk()
canvas = tk.Canvas(window, bg='white', height=1000, width=1000) #using the 1000 1000 gives a height of 50 and width of 100 tbh idk why
canvas.pack(fill=tk.BOTH, expand=True)

# make the grid from a given file and extract the blocked/unblocked data and set up gval and parent to initiall be set to infinity and (0,0) respectively 
def makeGrid(filename):
    f = open(filename, "r")

    coordinates = set() # used to keep track of the blocked areas
    place = 0

    #read the file and extract the necessary parts
    for line in f:
        if place == 1:
            endx, endy = line.split()
            endx = int(endx)
            endy = int(endy)
            place = place+1
        elif place == 0:
            startx,starty = line.split()
            startx = int(startx)
            starty = int(starty)
            place = place+1
        else:
            x,y,b = line.split() 
            b = int(b)
            x = int(x)
            y = int(y)
            if (b == 1):
                coordinates.add((x*10,y*10)) # this is for making the grid
            
            blocked.append(b) # getting the info abt blocked vs unblocked
            gval.append(float('inf')) # all the g vals are initialy infinity
            parent.append([0,0]) # all of the parents are just (0,0) initially
        

    # make a grid using what the file detailed, x goes from 1 to 100, y goes from 1 to 50, (1,1) is the top left corner   
    for i in range (10,1000,10): # the for loop makes the squares with size 10 across the entire canvas
        for j in range(10,500,10): # also in a sense we have coordinates now but in increments of 10 instead of 1, can't do one by one bcs then you just end up with a big black block since it is rly just the outlines smushed together
            if (i,j) in coordinates: # if the square is supposed to blocked it is filled gray, otherwise it is white
            #create rectangle has parameters x1,y1,x2,y2 where x1 y1 is the start coordinate and x2,y2 is the end coordinate
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black', fill='gray')
            else:
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'white')

    # use red circle for start and green for the end
    canvas.create_oval((startx*10)-4, (starty*10)-4, (startx*10)+4, (starty*10)+4, outline = 'black', fill='red') 
    canvas.create_oval((endx*10)-4, (endy*10)-4, (endx*10)+4, (endy*10)+4, outline = 'black', fill='green')

    f.close()
    return [startx,starty,endx,endy,blocked,gval,parent]


# general array method:
def findIndex (x,y): # gives the index for the arrays for gval,blocked and parent
    return ((x-1)*50) + y -1

# closed list method:
def cElementOf(x, y): # using closed array with the elements in the format (x,y)and want to know if a certain coordinate is already in the array
    if (x,y) not in closed:
        return 0
    else:
        return 1

# fringe methods: elements of the array (priority queue) are in the format [x,y],val
def elementOf(x, y): # want to know if a certain coordinate is already in the fringe
    if (len(fringe) == 0):
        return 0

    for i in (0,len(fringe)-1):
        xval = fringe[i][0][0] 
        yval = fringe[i][0][1]
        if x == xval and y == yval:
            return 1 
    return 0

def remove(x,y): # want to remove a certain coordinate from the fringe
    if (len(fringe) == 0):
        return

    for i in (0,len(fringe)-1):
        xval = fringe[i][0][0]
        yval = fringe[i][0][1]
        if x == xval and y == yval:
            fringe.pop(i)
            return

def insert(x, y, val): # want to insert a certain coordinate and value into the fringe
    if(len(fringe) == 0): # if the array has ntg in it, just add it
        fringe.append([[x,y],val])
        return 

    for i in (0,len(fringe)-1): # if the array has values, to make it a priority queue, insert it a certain way
        value = fringe[i][1]
        if (val>value):
            fringe.insert(i,[[x,y],val]) # insert in a way that the first element will be largest -> go in decreasing order and the last is the smallest val (this gets popped first)
            return
    fringe.append([[x,y],val]) # if it gets through the for loop without adding, add to the end if it has the smallest val

# heuristic 
def heuristic(x,y,endx,endy):
   a = math.sqrt(2)
   e = min(abs(x-endx), abs(y-endy))
   i = max(abs(x-endx), abs(y-endy))
   o = min(abs(x-endx), abs(y-endy))
   u = (a*e) + i - o
   return u

# c function
def cfunc(a, b, c, d): # finds the distance btwn two points
    xd = c-a
    xd = math.pow(xd,2)
    yd = d-b
    yd = math.pow(yd,2)
    dist = math.sqrt(xd+yd)
    return dist

# finding successors used for both A* and theta
def findSuccessor (x,y,blocked,successor): 
    if (x+1 < 101): # checking the right side
        if (y == 1): 
            if not(blocked[findIndex(x,y)] == 1): # making sure it isn't on the top edge and has a blocked square below
                successor.append([x+1,y])
        elif(y == 50):
            if not(blocked[findIndex(x,y-1)] == 1): # making sure it isn't on the bottom edge and has a blocked square above
                successor.append([x+1,y])
        elif not ((blocked[findIndex(x,y-1)] == 1) and (blocked[findIndex(x,y)]==1)): # making sure both above and below aren't blocked
                successor.append([x+1,y])

        if ((y-1 > 0) and (blocked[findIndex(x,y-1)] == 0)): # making sure it doesn't go diagonally up through a blocked square
            successor.append([x+1,y-1]) 

        if((y+1<51) and (blocked[findIndex(x,y)] == 0)): # making sure it doesn't go diagonally down through a blocked square
            successor.append([x+1,y+1])

    if (x-1 > 0): # checking the left side
        if y == 1:
            if not(blocked[findIndex(x-1,y)] == 1): # making sure it isn't on the top edge and has a blocked square below
                successor.append([x-1,y])
        elif y == 50:
            if not(blocked[findIndex(x-1,y-1)] == 1): # making sure it isn't on the bottom edge and has a blocked square above
                successor.append([x-1,y])
        elif not((blocked[findIndex(x-1,y)] == 1) and (blocked[findIndex(x-1,y-1)] == 1)): # making sure both above and below aren't blocked
            successor.append([x-1,y])
        
        if((y-1 > 0) and (blocked[findIndex(x-1,y-1)] == 0)): # making sure it doesn't go diagonally up through a blocked square
            successor.append([x-1,y-1]) 
        if((y+1 < 51) and (blocked[findIndex(x-1,y)] == 0)): # making sure it doesn't go diagonally down through a blocked square
            successor.append([x-1,y+1])

    if(y+1 < 51): # checking below
        if x==1:
            if not (blocked[findIndex(x,y)] == 1): # making sure it isn't on the left edge and has a blocked square to the right
                successor.append([x,y+1])
        elif x == 100:
            if not(blocked[findIndex(x-1,y)] == 1): # making sure it isn't on the right edge and has a blocked square to the left
                successor.append([x,y+1])
        elif not ((blocked[findIndex(x,y)] == 1) and (blocked[findIndex(x-1,y)] == 1)): # making sure both the left and right aren't blocked
            successor.append([x,y+1])

    if(y-1 > 0): # checking above
        if x == 1: 
            if not(blocked[findIndex(x,y-1)] == 1): # making sure it isn't on the left edge and has a blocked square to the right
                successor.append([x,y-1])
        elif x == 100:
            if not(blocked[findIndex(x-1,y-1)] == 1): # making sure it isn't on the right edge and has a blocked square to the left
                successor.append([x,y-1])
        elif not((blocked[findIndex(x,y-1)] == 1) and (blocked[findIndex(x-1,y-1)] == 1)): # making sure both the left and right aren't blocked
            successor.append([x,y-1])
    return successor

# finding the path used for both A* and theta
def createPath(parent,startx,starty,endx,endy,path):
    index = findIndex(endx,endy)
    [px,py] = parent[index]
    path.append([endx,endy])
    counter = 0
    while counter != 2: 
        path.append(parent[index])
        index = findIndex(px,py)
        [px,py] = parent[index]
        if px == startx and py == starty:
            counter = counter+1   
    return path

# A* specific methods
def UpdateVertex(a,b, c, d, gval,endx,endy): 
    index_s = findIndex(a,b)
    index_sprime = findIndex(c,d)
    cval = cfunc(a,b,c,d)

    if gval[index_s] + cval < gval[index_sprime]:
        gval[index_sprime] = gval[index_s] +cval
        parent[index_sprime] = [a,b]
        if elementOf(c,d):
            remove(c,d)
        
        val = gval[index_sprime] + heuristic(c,d,endx,endy)
        insert(c, d, val)

def traceBack(path,startx,starty,endx,endy): # used to trace the path from the start vertex to the end vertex
    [px,py] = path.pop()
    while len(path)!= 0:
        [xi,yi] = path.pop()
        if((px-xi == 1) and (py-yi == 1)): # left and up ~ diagonal
            i = (px-1)*10
            j = (py-1)*10
            canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif((px-xi==1) and (py-yi == -1)): #left and down ~ diagonal
            i = (px-1)*10
            j = py*10
            canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif((px-xi == -1) and (py-yi == 1)): # right and up ~ diagonal
            i = px*10
            j = (py-1)*10
            canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif((px-xi == -1) and (py-yi == -1)): # right and down ~ diagonal
            i = px*10
            j = py*10
            canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif((px-xi == 1) and (py-yi == 0)): # only moved left
            if(py == 1): # if y = 1 shade the one below
                i = (px-1)*10
                j = py*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            elif(blocked[findIndex(px-1,py-1)] == 1): # if the one above is blocked shade the one below
                i = (px-1)*10
                j = py*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            else: # shade above if there are no restrictions
                i = (px-1)*10
                j = (py-1)*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif((px-xi == -1) and (py-yi == 0)): # only moved right
            if(py == 1): # if y = 1 shade the one below
                i = px*10
                j = py*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            elif(blocked[findIndex(px,py-1)] == 1): # if the one above is blocked shade the one below
                i = px*10
                j = py*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            else: # shade above if there are no restrictions
                i = px*10
                j = (py-1)*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif((px-xi == 0) and (py-yi == 1)): # only moved up
            if(px == 100): # if x = 100 shade the one on the left
                i = (px-1)*10
                j = (py-1)*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            elif(blocked[findIndex(px,py-1)] == 1): # if the one on the right is blocked shade the one on the left
                i = (px-1)*10
                j = (py-1)*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            else: # shade the one on the right if there are no restrictions
                i = px*10
                j = (py-1)*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        elif((px-xi == 0) and (py -yi == -1)): # only moved down
            if(px == 100): # if x = 100 shade the one on the left
                i = (px-1)*10
                j = py*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            elif(blocked[findIndex(px,py-1)] == 1): # if the one on the right is blocked shade the one on the left
                i = (px-1)*10
                j = py*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
            else: # shade the one on the right if there are no restrictions
                i = px*10
                j = py*10
                canvas.create_rectangle(i, j, i+10, j+10, outline = 'black',fill = 'blue')
        
        px = xi
        py = yi
    
    # plot the start and end again so that it is above all of the shading - just for clarity purpose
    canvas.create_oval((startx*10)-4, (starty*10)-4, (startx*10)+4, (starty*10)+4, outline = 'black', fill='red') 
    canvas.create_oval((endx*10)-4, (endy*10)-4, (endx*10)+4, (endy*10)+4, outline = 'black', fill='green')


def A_star(a,b,c,d,blocked,gval,parent):
    startx = a
    starty = b
    endx = c
    endy = d
    indexS = findIndex(startx,starty)
    gval[indexS] = 0
    parent[indexS] = [startx,starty]
    val = gval[indexS] +heuristic(startx,starty,endx,endy)
    insert(startx,starty,val)

    while len(fringe) != 0:
        [[x,y],v] = fringe.pop()
        if x == endx and y == endy:
            print("path found")
            path = []
            path = createPath(parent,startx,starty,endx,endy,path)
            traceBack(path,startx,starty,endx,endy)
            return
            
        closed.append((x,y))
        
        successor = []
        successor = findSuccessor(x,y,blocked,successor) 
       
        while len(successor) != 0:
            [sx,sy] = successor.pop()
            if not cElementOf(sx, sy):
                if not elementOf(sx,sy):
                    si = findIndex(sx,sy)
                    gval[si] = float('inf')
                    parent[si] = None 
                UpdateVertex(x,y,sx,sy,gval,endx,endy)
        
    print("no path found")
    return 




# main method and keeping the window open:
def main():
    [startx,starty,endx,endy,blocked,gval,parent] = makeGrid("grid.txt")
    A_star(startx,starty,endx,endy,blocked,gval,parent)

if __name__ == "__main__":
    main()

window.mainloop()

    
    
