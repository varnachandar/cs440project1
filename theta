import tkinter as tk
import random # to generate a random no. for the index to block
import os
import math

f = open("grid.txt", "r")


blocked = []
gval = []
parent = []


place = 0 # to keep track of just the first two lines
for line in f:
    if place == 1:
        endx, endy = line.split()
        endx = int(endx)
        endy = int(endy)
        place = place+1
    elif place == 0:
        startx,starty = line.split()
        startx = int(startx)
        starty = int(starty)
        place = place+1
    else:
        x,y,b = line.split() # don't rly need x and y we can find them on our own
        b = int(b)
        blocked.append(b) 
        gval.append(0) # all the g vals are initialy 0
        parent.append([0,0]) # all of the parents are just (0,0) initially


fringe = [] # can insert before other elements according to the distance 

closed = set() # no duplicates allowed and can find if smtg is in it or not and order of adding doesn't matter



def heuristic(x,y):
   #return 0
   a = math.sqrt(2)
   e = min(abs(x-endx), abs(y-endy))
   i = max(abs(x-endx), abs(y-endy))
   o = min(abs(x-endx), abs(y-endy))
   u = (a*e) + i - o
   
   return u


def findIndex (x,y): # gives the index for the arrays for gval and parent
    return ((x-1)*50) + y -1

def cfunc(a, b, c, d): # finds the distance btwn two points
    xd = c-a
    xd = math.pow(xd,2)
    yd = d-b
    yd = math.pow(yd,2)
    d = math.sqrt(xd+yd)
    return d

def elementOf(arrayx, x, y): # using an array with the elements in the format [x,y], val; want to know if a certain coordinate is already in the array
    if (len(arrayx) == 0):
        return 0

    for i in (0,len(arrayx)-1):
        xval = arrayx[i][0][0] 
        yval = arrayx[i][0][1]
        if x == xval and y == yval:
            return 1 # 1 if the coordinate is in the array already
    return 0

def remove(arrayx,x,y): # want to remove a certain coordinate from the array again in the format [x,y],val
    if (len(arrayx) == 0):
        return

    for i in (0,len(arrayx)-1):
        xval = arrayx[i][0][0]
        yval = arrayx[i][0][1]
        if x == xval and y == yval:
            arrayx.pop(i)
            return

def insert(arrayx, x, y, val): # insert to an array of format [x,y]
    if(len(arrayx) == 0): # if the array has ntg in it, just append
        arrayx.append([[x,y],val])
        return 

    for i in (0,len(arrayx)-1): # if the array has values, to make it a priority queue, insert it a certain way
        value = arrayx[i][1]
        if (val<value):
            arrayx.insert(i,[[x,y],val]) # insert in a way that the first element will be smallest and we go in increasing order and the last is the largest val
            return
    arrayx.append([[x,y],val]) # add to the end if it has the greatest val


def LineOfSight(a,b,c,d):
    x0 = a
    y0 = b
    x1 = c
    y1 = d
    f = 0
    dy = y1 - y0
    dx = x1-x0

    
    if dy<0:
        dy = -1*dy
        dod_y = -1 # direction of difference between y1 and y0
    else:
        dod_y = 1
    
    if dx <0:
        dx = -dx
        dod_x = -1 # direction of difference between x1 and x0
    else:
        dod_x = 1


     # sx = 1 return 0 else return -1
    if (dod_x == 1):
        s_x = 0
    else:   
        s_x = -1

    if (dod_y == 1):
        s_y = 0
    else:   
        s_y = -1
            

    if dx >= dy:
        while x0 != x1:
            f = f+dy
            if f >= dx:
                if gval[findIndex(x0+ s_x, y0+s_y)] == 1:
                    return False
                y0 = y0 + dod_y
                f = f-dx
            if f != 0 and gval[findIndex(x0+s_x, y0+s_y)] == 1:
                return False
            if dy == 0 and gval[findIndex(x0+s_x, y0)] == 1 and gval[findIndex(x0+s_x, y0-1)] == 1:
                return False
            x0 = x0 + dod_x
    else:
        while y0 != y1:
            f = f+ dx
            if f >= dy:
                if gval[findIndex(x0+s_x, y0+s_y)] == 1:
                    return False
                x0 = x0 + dod_x
                f = f-dy
            if f != 0 and gval[findIndex(x0+s_x, y0+s_y)] == 1:
                return False
            if dy == 0 and gval[findIndex(x0, y0+s_y)] == 1 and gval[findIndex(x0-1, y0 +s_y)] == 1:
                return False
            y0 = y0 + dod_y
    return True





def UpdateVertex(a,b, c, d): 

    index_s = findIndex(a,b)
    index_sprime = findIndex(c,d)
    cval = cfunc(a,b,c,d)
    [spx,spy] = parent[index_s]
    index_spt = findIndex(spx,spy)

    if LineOfSight(spx,spy,c,d):
        if((gval[index_spt]+ cfunc(spx,spy,c,d)) < gval[index_sprime]):
            gval[index_sprime] = gval[index_spt]+ cfunc(spx,spy,c,d)
            parent[index_sprime] = [spx,spy]
            if elementOf(fringe, c,d):
                remove(fringe, c, d)

            val = gval[index_sprime]+heuristic(c,d)
            insert(fringe, c, d, val)
        else:
            if gval[index_s] + cval  < gval[index_sprime]:
                gval[index_sprime] = gval[index_s] + cval
                parent[index_sprime] = [a,b]
                if elementOf(fringe,c,d):
                    remove(fringe,c,d)
                
                val = gval[index_sprime]+heuristic(c,d)
                insert(fringe,c,d,val)


successor = [] 

def findSuccessor (arrayx,x,y): # finding the 8 neighbors
    if (x+1 < 101):
        if(not ((y == 1 and blocked[findIndex(x,y)] == 1) or (y == 50 and blocked[findIndex(x,y+1)] == 1))): # if we are at the top or bottom and its blocked
            if(not(blocked[findIndex(x,y)] == 1 and blocked[findIndex(x,y+1)] == 1)): # if going right and it is blocked and the one above is blocked
                arrayx.append([x+1,y])
        if(y+1 < 51) and blocked[findIndex(x,y+1)] != 1: # we aren't going diagonal up right through a blocked one
            arrayx.append([x+1,y+1])
        if(y-1 > 0) and blocked[findIndex(x,y)] != 1: #don't go diagonally down right through blocked one
            arrayx.append([x+1,y-1])
    if (x-1 > 0):
        if(not ((y == 1 and blocked[findIndex(x-1,y)] == 1) or (y == 50 and blocked[findIndex(x-1,y+1)] == 1))): # if we are at the top or bottom and its blocked
            if(not(blocked[findIndex(x-1,y)] == 1 and blocked[findIndex(x-1,y+1)] == 1)): # if going left and the left one and the one above the left one is blocked
                arrayx.append([x-1,y])
        if(y+1 < 51) and blocked[findIndex(x-1,y-1)] != 1: # we aren't going diagonal up left through a blocked one
            arrayx.append([x-1,y+1])
        if(y-1 > 0) and blocked[findIndex(x-1,y)] != 1: # not going diagonally down left
            arrayx.append([x-1,y-1])
    if(y+1 < 51):
        if not ((x == 1 and blocked[findIndex(x,y+1)] == 1)  or (x == 100 and blocked[findIndex(x-1,y+1)] == 1)): # on the edge and blocked
            if(not(blocked[findIndex(x,y+1)] == 1 and blocked[findIndex(x-1,y+1)] == 1)): # if going up, the one above and the one to the left of the above isn't blocked
                arrayx.append([x,y+1])
    if(y-1 > 0):
        if not ((x == 1 and blocked[findIndex(x,y)] == 1)  or (x == 100 and blocked[findIndex(x-1,y)] == 1)): # on the edge and blocked
             if(not(blocked[findIndex(x,y-1)] == 1 and blocked[findIndex(x-1,y-1)] == 1)): # if going down, the one below and the one to the left of the below isn't blocked
                arrayx.append([x,y-1])



def main():
    indexS = findIndex(startx,starty)
    gval[indexS] = 0
    parent[indexS] = [startx,starty]
    val = gval[indexS]+heuristic(startx,starty)
    insert(fringe, startx,starty,val)

    while len(fringe) != 0:
        [[x,y],v] = fringe.pop()
       
        if x == endx and y == endy:
            print("hi")
            return 

        closed.add((x,y))


        findSuccessor(successor,x,y)

        

        while len(successor) != 0:
            [sx,sy] = successor.pop()
            if not (sx, sy) in closed:
                if not elementOf(fringe,sx,sy):
                    si = findIndex(sx,sy)
                    gval[si] = float('inf')
                UpdateVertex(x,y,sx,sy)

    print("bye")
    return 
    


    


if __name__ == "__main__":
    main()


